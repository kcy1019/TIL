<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Google Kick Start 2019 Round B</title>
  <meta name="description" content="오늘 오전에는 Kick Start Round B가 있었다. 난이도는 Round A처럼 역시 어려웠다(ㅠㅠ). 다만 각 문제가 다이나믹 프로그래밍, 그리디, 그리고 라인 스위핑 등 기본적인 알고리즘의 의미를 충실하게 고민하면 풀 수 있는 구성으로, PS를 다시 연습하기에 훌륭한 대회였다.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://a.cyclic.dev/day34/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Splinters of Life" href="https://a.cyclic.dev/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="kcy1019">
  <meta name="twitter:title" content="Google Kick Start 2019 Round B">
  <meta name="twitter:description" content="오늘 오전에는 Kick Start Round B가 있었다. 난이도는 Round A처럼 역시 어려웠다(ㅠㅠ). 다만 각 문제가 다이나믹 프로그래밍, 그리디, 그리고 라인 스위핑 등 기본적인 알고리즘의 의미를 충실하게 고민하면 풀 수 있는 구성으로, PS를 다시 연습하기에 훌륭한 대회였다.">
  
    <meta name="twitter:creator" content="kcy1019">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-47828880-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-47828880-3');
</script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: {
        equationNumbers: {
          autoNumber: "AMS"
        }
      },
      tex2jax: {
        inlineMath: [ ['$','$'] ],
        displayMath: [ ['$$','$$'] ],
        processEscapes: true,
      }
    });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Splinters of Life</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="https://lucent.me">About</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Google Kick Start 2019 Round B</h1>
    
    <p class="post-meta"><time datetime="2019-04-21T02:33:30+00:00" itemprop="datePublished">Apr 21, 2019</time> •
  
    
    
      
    
      
        <a href="/categories/ps/">ps</a>
      
    
      
    
      
    
  



</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>오늘 오전에는 <a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda">Kick Start Round B</a>가 있었다.
난이도는 <a href="/day07">Round A</a>처럼 역시 어려웠다(ㅠㅠ).
다만 각 문제가 <a href="https://www.algorithmist.com/index.php/Dynamic_Programming">다이나믹 프로그래밍</a>, <a href="https://www.algorithmist.com/index.php/Greedy">그리디</a>, 그리고 <a href="https://en.wikipedia.org/wiki/Sweep_line_algorithm">라인 스위핑</a> 등
기본적인 알고리즘의 의미를 충실하게 고민하면 풀 수 있는 구성으로,
PS를 다시 연습하기에 훌륭한 대회였다.</p>

<ol id="markdown-toc">
  <li><a href="#building-palindromes" id="markdown-toc-building-palindromes">Building Palindromes</a></li>
  <li><a href="#energy-stones" id="markdown-toc-energy-stones">Energy Stones</a>    <ol>
      <li><a href="#test-set-1" id="markdown-toc-test-set-1">Test Set 1</a></li>
      <li><a href="#test-set-2" id="markdown-toc-test-set-2">Test Set 2</a></li>
    </ol>
  </li>
  <li><a href="#diverse-subarray" id="markdown-toc-diverse-subarray">Diverse Subarray</a></li>
</ol>

<h2 id="building-palindromes"><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda/0000000000119866">Building Palindromes</a></h2>

<p>알파벳 대문자로 이루어진 문자열 <code class="highlighter-rouge">S(1≤|S|≤100,000)</code>와 <code class="highlighter-rouge">Q</code>개의 독립적인 쿼리 <code class="highlighter-rouge">[L, R]</code>이 주어졌을 때,
각 쿼리에 대해 문자열 조각 <code class="highlighter-rouge">S[L:R+1]</code>을 재배열하여 팰린드롬을 만들 수 있는지 확인하는 문제이다.</p>

<p>이는 간단하게 구간 안에 존재하는 각 알파벳의 개수를 세어 확인할 수 있다.
홀수 개 존재하는 알파벳이 1개인 경우에는 해당 알파벳을 가운데에 놓음으로써 팰린드롬을 만들 수 있지만,
이러한 알파벳이 여럿 존재하면 팰린드롬을 만들 수 없으므로 간단히 해결 가능하다.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>

<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="n">MAXN</span><span class="p">]{};</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="mi">26</span><span class="p">][</span><span class="n">MAXN</span><span class="p">]{},</span> <span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">T</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">);</span> <span class="n">C</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">;</span> <span class="o">++</span><span class="n">C</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Case #%d: "</span><span class="p">,</span> <span class="n">C</span><span class="p">);</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d%s"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">d</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'A'</span> <span class="o">==</span> <span class="n">k</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
            <span class="kt">int</span> <span class="n">odd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                <span class="n">odd</span> <span class="o">+=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">odd</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h2 id="energy-stones"><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda/00000000001198c3">Energy Stones</a></h2>

<p>돌 몬스터가 점심으로 <code class="highlighter-rouge">N(1≤N≤100)</code>개의 에너지 스톤을 먹으려 한다.
각 에너지 스톤은 <code class="highlighter-rouge">S, E, L</code>의 값을 갖는데,
돌을 소화시키는 데에 <code class="highlighter-rouge">S(1≤S≤100)</code>만큼의 시간이 걸리고,
돌을 시간 0에 먹을 경우 <code class="highlighter-rouge">E</code>만큼의 에너지를 얻을 수 있다.
그리고 시간이 <code class="highlighter-rouge">1</code>만큼 지날 때 마다 <code class="highlighter-rouge">L</code>만큼 돌의 에너지가 줄어들어
결과적으로 시간 <code class="highlighter-rouge">T</code>에 돌을 먹을 경우 <code class="highlighter-rouge">max(0, E - L * T)</code>만큼의 에너지를 얻고,
먹는 데에는 시간이 걸리지 않지만, 소화시키는 데에 <code class="highlighter-rouge">S</code>만큼 걸려 <code class="highlighter-rouge">T = T + S</code>가 된다.</p>

<h3 id="test-set-1">Test Set 1</h3>

<p>이 데이터 셋에서는 모든 돌의 <code class="highlighter-rouge">S</code>가 같으므로 각 돌을 먹는 데에 걸리는 시간을 1이라고 간단히 생각할 수 있다.
따라서 먹을 돌의 집합이 “이미 결정된 상태” 에서는 <code class="highlighter-rouge">L</code>이 큰 것부터 순서대로 먹느 것이 최적인데,
그럼 먹을 돌의 집합은 어떻게 구해야 할까?</p>

<p>순서를 고정한 상태에서 최적의 부분집합을 선택하는 것은 <a href="http://courses.csail.mit.edu/6.006/fall11/rec/rec21_knapsack.pdf">0-1 냅색</a>을 이용해서 쉽게 해결할 수 있다.
즉, 주어진 돌을 미리 <code class="highlighter-rouge">L</code>이 감소하는 기준으로 정렬해 두고 냅색을 이용하면 최적의 순서로 선택했을 때
부분 집합이 갖는 에너지의 합을 구할 수 있다.</p>

<h3 id="test-set-2">Test Set 2</h3>

<p><code class="highlighter-rouge">S</code>가 다를 수 있으므로 아까보다 복잡해진 기분이 든다.
하지만, 결국 단위 시간당 줄어드는 에너지의 양, 즉 <code class="highlighter-rouge">L' = L / S</code>를 생각해 보면 아까와 별로 다를 것이 없음을 알 수 있다.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;tuple&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#define pb emplace_back
#define ALL(X) (X).begin(),(X).end()
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mi">111</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">v</span><span class="p">.</span><span class="n">pb</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">sort</span><span class="p">(</span><span class="n">ALL</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tie</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">MAXN</span> <span class="o">*</span> <span class="n">MAXN</span><span class="p">]{},</span> <span class="n">maxt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">maxt</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0LL</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">j</span> <span class="o">*</span><span class="mi">1LL</span><span class="o">*</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">d</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">maxt</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">*</span><span class="n">max_element</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="o">++</span><span class="n">maxt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">T</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">);</span> <span class="n">C</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">;</span> <span class="o">++</span><span class="n">C</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Case #%d: "</span><span class="p">,</span> <span class="n">C</span><span class="p">);</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d%d"</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">solve</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h2 id="diverse-subarray"><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda/00000000001198c1">Diverse Subarray</a></h2>

<p>길이 N(1≤N≤100,000)의 정수 배열이 주어진다.
배열의 각 원소 A[i]가 장식품의 종류를 나타낼 때,
이 배열에서 가장 많은 원소가 포함된 연속한 부분 배열을 선택하는 문제이다.
여기까진 간단해 보이지만,  조금 특이한 제한 조건이 있다:
각 종류별 장식품을 S개 보다 많이 선택할 경우, 해당 종류는 모두 압수당해서 0개가 되어버린다는 것이다.</p>

<p>테스트 셋 1은 N의 제한 조건이 1≤N≤1,000 이므로 모든 부분 배열을 순회하여 해결할 수 있다.
한편, 테스트 셋 2의 경우에는 그렇게 간단히는 해결할 수 없다.
즉, 모든 부분 배열을 확인하지 않고 최적의 부분 배열을 찾아야 한다.</p>

<p>우선 테스트 셋 1번을 해결하는 알고리즘을 ‘조금 복잡하게’ 만들어 보자.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">1</th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">4</th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">4</th>
      <th style="text-align: center">4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">+1</td>
      <td style="text-align: center">+1</td>
      <td style="text-align: center">+1</td>
      <td style="text-align: center"><a>-2</a></td>
      <td style="text-align: center">+1</td>
      <td style="text-align: center">-2</td>
    </tr>
  </tbody>
</table>

<p>위쪽 행은 예제 수열, 그리고 아래는 S = 2인 경우 각각의 원소까지 선택했을 때
부분 배열 안에 남게 되는 장식품의 수의 변화값을 나타낸다.
즉, 맨 앞의 1만 선택하면 (0) + 1 = 1개가 남고, 네 번째 원소까지 고를 경우
(0) + 1 + 1 + 1 - 2 = 1개가 남는다.
이렇게 시작점이 맨 앞으로 고정돼 있는 경우의 최적 부분 배열은 3번째 원소까지 고른 것(=3)임을 알 수 있다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><font color="gray">1</font></th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">4</th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">4</th>
      <th style="text-align: center">4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><font color="gray">±0</font></td>
      <td style="text-align: center">+1</td>
      <td style="text-align: center">+1</td>
      <td style="text-align: center"><a>+1</a></td>
      <td style="text-align: center">+1</td>
      <td style="text-align: center">-2</td>
    </tr>
  </tbody>
</table>

<p>이번엔 부분 배열의 시작 위치를 한 칸 옮긴 상태를 생각해 보자.
이 경우의 최적 부분 배열은 다섯 번째 원소까지(=4)가 된다.</p>

<p>여기서 눈여겨 봐야 할 것은 시작 점을 바꿀 때 바뀐 부분(파란 색) 이다.
시작 점이 바뀌더라도 실제로 갱신해야 할 값은 이전 시작 점과 같은 값을 갖는 S번째, 그리고 S + 1번째 값 뿐임을 알 수 있다.</p>

<p>이를 바탕으로 다시 코드를 작성해 보면 다음과 같다.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;deque&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#define sz size()
#define pb emplace_back
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">T</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">);</span> <span class="n">C</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">;</span> <span class="o">++</span><span class="n">C</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Case #%d: "</span><span class="p">,</span> <span class="n">C</span><span class="p">);</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">MAXN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">sz</span> <span class="o">==</span> <span class="n">s</span> <span class="o">?</span> <span class="o">-</span><span class="n">s</span> <span class="o">:</span> <span class="n">q</span><span class="p">.</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="n">s</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pb</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">ptr</span><span class="p">[</span><span class="n">MAXN</span><span class="p">]{},</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">e</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">e</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// can be eliminated</span>
                <span class="n">cur</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">e</span><span class="p">]][</span><span class="n">ptr</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">e</span><span class="p">]]</span><span class="o">++</span><span class="p">]];</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">]].</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="n">v</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">]][</span><span class="n">s</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">]].</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">v</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">]][</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">s</span><span class="p">;</span>
            <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">]].</span><span class="n">pop_front</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>결과적으로 이렇게 구하더라도 여전히 시간 복잡도는 배열 길이의 제곱에 비례한다.
하지만, 이제 코드에서 <strong>시간을 줄일 수 있는 부분이 확실하게 보인다: 바로 합을 구하는 루프!</strong></p>

<p>이는 <a href="https://www.acmicpc.net/blog/view/9">세그먼트 트리</a>와 같은 자료 구조를 이용하여 원소 수의 로그에 비례하는 시간에 구할 수 있다.
더욱이, 시작점이 바뀔 때 마다 업데이트 하는 연산 역시도 로그 시간에 수행할 수 있다.
따라서 모든 시작점에 대해 최적 부분 배열을 로그 시간에 구할 수 있으므로 총 시간 복잡도는 $O(n\log{n})$이 된다.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;deque&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#define sz size()
#define pb emplace_back
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">PrefixSumNode</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">ReturnType</span><span class="p">;</span>
    <span class="n">ReturnType</span> <span class="n">sum</span><span class="p">,</span> <span class="n">prefix</span><span class="p">;</span>
    <span class="kr">inline</span> <span class="n">PrefixSumNode</span><span class="p">(</span><span class="n">ReturnType</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">prefix</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kr">inline</span> <span class="n">ReturnType</span> <span class="n">query</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">prefix</span><span class="p">;</span> <span class="p">}</span>
    <span class="kr">inline</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="k">const</span> <span class="n">ReturnType</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
    <span class="kr">inline</span> <span class="n">PrefixSumNode</span> <span class="n">combine</span><span class="p">(</span><span class="k">const</span> <span class="n">PrefixSumNode</span><span class="o">&amp;</span> <span class="n">le</span><span class="p">,</span> <span class="k">const</span> <span class="n">PrefixSumNode</span><span class="o">&amp;</span> <span class="n">ri</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">le</span><span class="p">.</span><span class="n">sum</span> <span class="o">+</span> <span class="n">ri</span><span class="p">.</span><span class="n">sum</span><span class="p">;</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">le</span><span class="p">.</span><span class="n">prefix</span><span class="p">,</span> <span class="n">le</span><span class="p">.</span><span class="n">sum</span> <span class="o">+</span> <span class="n">ri</span><span class="p">.</span><span class="n">prefix</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Node</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">SegmentTree</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Node</span><span class="o">::</span><span class="n">ReturnType</span> <span class="n">T</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

    <span class="kr">inline</span> <span class="n">SegmentTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="n">size</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">[</span><span class="n">size</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kr">inline</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nodes</span><span class="p">[</span><span class="n">size</span><span class="o">+</span><span class="n">p</span><span class="p">].</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">le</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">ri</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span> <span class="n">le</span> <span class="o">=</span> <span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">else</span> <span class="n">ri</span> <span class="o">=</span> <span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">parent</span><span class="p">].</span><span class="n">combine</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">le</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">ri</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kr">inline</span> <span class="n">T</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="n">le</span><span class="p">,</span> <span class="n">ri</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">+=</span> <span class="n">size</span><span class="p">,</span> <span class="n">r</span> <span class="o">+=</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">;</span> <span class="n">l</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">le</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">le</span><span class="p">,</span> <span class="n">nodes</span><span class="p">[</span><span class="n">l</span><span class="o">++</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">ri</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="o">--</span><span class="n">r</span><span class="p">],</span> <span class="n">ri</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">tmp</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">le</span><span class="p">,</span> <span class="n">ri</span><span class="p">).</span><span class="n">query</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kr">inline</span> <span class="o">~</span><span class="n">SegmentTree</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">nodes</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">T</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">);</span> <span class="n">C</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">;</span> <span class="o">++</span><span class="n">C</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Case #%d: "</span><span class="p">,</span> <span class="n">C</span><span class="p">);</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">SegmentTree</span><span class="o">&lt;</span><span class="n">PrefixSumNode</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
            <span class="n">tree</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">sz</span> <span class="o">==</span> <span class="n">s</span> <span class="o">?</span> <span class="o">-</span><span class="n">s</span> <span class="o">:</span> <span class="n">q</span><span class="p">.</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="n">s</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pb</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">tree</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">]].</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="n">tree</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">]][</span><span class="n">s</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">]].</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">tree</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">]][</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">s</span><span class="p">);</span>
            <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">]].</span><span class="n">pop_front</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>


  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://a.cyclic.dev/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
